package org.firstinspires.ftc.teamcode.vision;

import org.firstinspires.ftc.teamcode.util.BlobStats;
import org.opencv.core.*;
import org.opencv.features2d.Features2d;
import org.opencv.features2d.SimpleBlobDetector;
import org.opencv.imgproc.*;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * GripPipeline class.
 *
 * <p>An OpenCV pipeline generated by GRIP.
 *
 * @author GRIP
 */
public class SkystoneGripPipeline {

    //Outputs
    private Mat blurOutput = new Mat();
    private Mat cropOutput = new Mat();
    private Mat hsvThresholdOutput = new Mat();
    private Mat contoursOutput = new Mat();

    //Statistics
    List<BlobStats> blobs = new ArrayList<BlobStats>();
    List<MatOfPoint> mContours = new ArrayList<MatOfPoint>();
    SkystoneTargetInfo info = new SkystoneTargetInfo();

    //need to be tuned
    private static final int LEFT_BOUND = 575, RIGHT_BOUND = 1100;

    /**
     * This is the primary method that runs the entire pipeline and updates the outputs.
     */
    public Mat process(Mat source0) {

        // Step Blur0:
        Mat blurInput = source0;
        BlurType blurType = BlurType.get("Gaussian Blur");
        double blurRadius = 19.81981981981982;
        blur(blurInput, blurType, blurRadius, blurOutput);

        // Step crop:
        Mat cropInput = blurOutput.clone();
        cropOutput = crop(cropInput, new Point(161, 181), new Point(600, 328));

        // Step HSV_Threshold0:
        Mat hsvThresholdInput = cropOutput;
        double[] hsvThresholdHue = {0.0, 180.0};
        double[] hsvThresholdSaturation = {0.0, 255.0};
        double[] hsvThresholdValue = {4.586330935251798, 91.86868686868685};
        hsvThreshold(hsvThresholdInput, hsvThresholdHue, hsvThresholdSaturation, hsvThresholdValue, hsvThresholdOutput);

        // Filter contours by area and resize to fit the original image size

        Mat contoursInput = hsvThresholdOutput;
        List<MatOfPoint> contours = new ArrayList<MatOfPoint>();
        List<BlobStats> blobs = new ArrayList<BlobStats>();

        Imgproc.findContours(contoursInput, contours, new Mat(), Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE);

        // Find max contour area
        double maxArea = 0;
        Iterator<MatOfPoint> each = contours.iterator();
        while (each.hasNext()) {
            MatOfPoint wrapper = each.next();
            double area = Imgproc.contourArea(wrapper);
            if (area > maxArea)
                maxArea = area;
        }

        // Filter contours by area and resize to fit the original image size
        mContours.clear();
        each = contours.iterator();
        while (each.hasNext()) {
            MatOfPoint contour = each.next();
            if (Imgproc.contourArea(contour) > 0.1*maxArea) {
                Core.multiply(contour, new Scalar(4,4), contour);
                mContours.add(contour);
                Moments p = Imgproc.moments(contour, false);
                int x = (int) (p.get_m10() / p.get_m00());
                int y = (int) (p.get_m01() / p.get_m00());
                double area = Imgproc.contourArea(contour);
                org.opencv.core.Rect blobBox = Imgproc.boundingRect(contour);
                BlobStats blob = new BlobStats(p,x,y,blobBox.width,blobBox.height,area);
                blobs.add(blob); //put it in the List
                Imgproc.circle(hsvThresholdOutput, new Point(x, y), 5, new Scalar(0, 255, 0, 255), 5);
            }
            Imgproc.drawContours(hsvThresholdOutput, mContours, -1, new Scalar(0, 255, 0, 255), 3);
        }

        BlobStats mainBlob = blobs.get(blobs.size() - 1);
        StonePos pos = (mainBlob.x <= LEFT_BOUND ? StonePos.SOUTH : (mainBlob.x >= RIGHT_BOUND ? StonePos.NORTH : StonePos.MIDDLE));

        info = new SkystoneTargetInfo(mainBlob.x, mainBlob.y, mainBlob.width, mainBlob.height, pos);

        this.blobs = blobs;
        return hsvThresholdOutput;
    }

    /**
     * An indication of which type of filter to use for a blur.
     * Choices are BOX, GAUSSIAN, MEDIAN, and BILATERAL
     */
    enum BlurType{
        BOX("Box Blur"), GAUSSIAN("Gaussian Blur"), MEDIAN("Median Filter"),
        BILATERAL("Bilateral Filter");

        private final String label;

        BlurType(String label) {
            this.label = label;
        }

        public static BlurType get(String type) {
            if (BILATERAL.label.equals(type)) {
                return BILATERAL;
            }
            else if (GAUSSIAN.label.equals(type)) {
                return GAUSSIAN;
            }
            else if (MEDIAN.label.equals(type)) {
                return MEDIAN;
            }
            else {
                return BOX;
            }
        }

        @Override
        public String toString() {
            return this.label;
        }
    }

    /**
     * Softens an image using one of several filters.
     * @param input The image on which to perform the blur.
     * @param type The blurType to perform.
     * @param doubleRadius The radius for the blur.
     * @param output The image in which to store the output.
     */
    private void blur(Mat input, BlurType type, double doubleRadius,
                      Mat output) {
        int radius = (int)(doubleRadius + 0.5);
        int kernelSize;
        switch(type){
            case BOX:
                kernelSize = 2 * radius + 1;
                Imgproc.blur(input, output, new Size(kernelSize, kernelSize));
                break;
            case GAUSSIAN:
                kernelSize = 6 * radius + 1;
                Imgproc.GaussianBlur(input,output, new Size(kernelSize, kernelSize), radius);
                break;
            case MEDIAN:
                kernelSize = 2 * radius + 1;
                Imgproc.medianBlur(input, output, kernelSize);
                break;
            case BILATERAL:
                Imgproc.bilateralFilter(input, output, -1, radius, radius);
                break;
        }
    }

    /**
     * Segment an image based on hue, saturation, and value ranges.
     *
     * @param input The image on which to perform the HSL threshold.
     * @param hue The min and max hue
     * @param sat The min and max saturation
     * @param val The min and max value
     * @param out The image in which to store the output.
     */
    private void hsvThreshold(Mat input, double[] hue, double[] sat, double[] val,
                              Mat out) {
        Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2HSV);
        Core.inRange(out, new Scalar(hue[0], sat[0], val[0]),
                new Scalar(hue[1], sat[1], val[1]), out);
    }

    /**
     * Detects groups of pixels in an image.
     * @param input The image on which to perform the find blobs.
     * @param minArea The minimum size of a blob that will be found
     * @param circularity The minimum and maximum circularity of blobs that will be found
     * @param darkBlobs The boolean that determines if light or dark blobs are found.
     * @param blobList The output where the MatOfKeyPoint is stored.
     */
    private void findBlobs(Mat input, double minArea, double[] circularity,
                           Boolean darkBlobs, MatOfKeyPoint blobList) {

        SimpleBlobDetector blobDet = SimpleBlobDetector.create();

        blobDet.detect(input, blobList);
    }

    private Mat crop(Mat image, Point topLeftCorner, Point bottomRightCorner) {
        Rect cropRect = new Rect(topLeftCorner, bottomRightCorner);
        return new Mat(image, cropRect);
    }


}
